# ------------------------------------------------ COMMENTS ------------------------------------------------------------


# -------------------------------------------- IMPORT MODULES ----------------------------------------------------------

import numpy as np
import pandas as pd


# ------------------------------------------------ OBJECTS -------------------------------------------------------------

def ek_square(kx=None, ky=None, t=1.0, tp=0.0, tpp=0.0):
    return - 2. * t * (np.cos(kx) + np.cos(ky)) - 4. * tp * np.cos(kx) * np.cos(ky) \
           - 2. * tpp * (np.cos(2. * kx) + np.cos(2. * ky))


def ekpq_3d(kx=None, ky=None, kz=None, qx=0, qy=0, qz=0, t_mat=None):
    kx = kx + qx
    ky = ky + qy
    kz = kz + qz
    ek = - 2.0 * (t_mat[0, 0] * np.cos(kx) + t_mat[0, 1] * np.cos(ky) + t_mat[0, 2] * np.cos(kz))
    ek = ek - 2.0 * (t_mat[1, 0] * np.cos(kx + ky) + t_mat[1, 1] * np.cos(kx - ky))
    ek = ek - 2.0 * (t_mat[2, 0] * np.cos(2. * kx) + t_mat[2, 1] * np.cos(2. * ky) + t_mat[2, 2] * np.cos(kz))
    return ek


def ek_3d(kgrid=None, hr=None):
    kx = kgrid[0][:, None, None]
    ky = kgrid[1][None, :, None]
    kz = kgrid[2][None, None, :]
    ek = - 2.0 * (hr[0, 0] * np.cos(kx) + hr[0, 1] * np.cos(ky) + hr[0, 2] * np.cos(kz))
    ek = ek - 2.0 * (hr[1, 0] * np.cos(kx + ky) + hr[1, 1] * np.cos(kx - ky))
    ek = ek - 2.0 * (hr[2, 0] * np.cos(2. * kx) + hr[2, 1] * np.cos(2. * ky) + hr[2, 2] * np.cos(kz))
    return ek


# ==================================================================================================================
def read_Hk_w2k(fname, spin_sym = True):
    """ Reads a Hamiltonian f$ H_{bb'}(k) f$ from a text file.

    Expects a text file with white-space separated values in the syntax as
    generated by wannier90:  the first line is a header with three integers,
    optionally followed by '#'-prefixed comment:

        <no of k-points> <no of wannier functions> <no of bands (ignored)>

    For each k-point, there is a header line with the x, y, z coordinates of the
    k-point, followed by <nbands> rows as lines of 2*<nbands> values each, which
    are the real and imaginary part of each column.

    Returns: A pair (hk, kpoints):
     - hk       three-dimensional complex array of the Hamiltonian H(k),
                where the first index corresponds to the k-point and the other
                dimensions mark band indices.
     - kpoints  two-dimensional real array, which contains the
                components (x,y,z) of the different kpoints.
    """
    hk_file = open(fname,'r')
    spin_orbit = not spin_sym
    def nextline():
        line = hk_file.readline()
        return line[:line.find('#')].split()

    # parse header
    header = nextline()
    if header[0] == 'VERSION':
        warn("Version 2 headers are obsolete (specify in input file!)")
        nkpoints, natoms = map(int, nextline())
        lines = np.array([nextline() for _ in range(natoms)], np.int)
        nbands = np.sum(lines[:, :2])
        del lines, natoms
    elif len(header) != 3:
        warn("Version 1 headers are obsolete (specify in input file!)")
        header = list(map(int, header))
        nkpoints = header[0]
        nbands = header[1] * (header[2] + header[3])
    else:
        nkpoints, nbands, _ = map(int, header)
    del header

    # nspins is the spin dimension for H(k); G(iw), Sigma(iw) etc. will always
    # be spin-dependent
    if spin_orbit:
        if nbands % 2: raise RuntimeError("Spin-structure of Hamiltonian!")
        nbands //= 2
        nspins = 2
    else:
        nspins = 1
    # GS: inside read_hamiltonian nspins is therefore equal to 1 if spin_orbit=0
    # GS: outside nspins is however always set to 2. Right?
    # GS: this also means that we have to set nspins internally in read_ImHyb too

    hk_file.flush()

    # parse data
    hk = np.fromfile(hk_file, sep=" ")
    hk = hk.reshape(-1, 3 + 2 * nbands ** 2 * nspins ** 2)
    kpoints_file = hk.shape[0]
    if kpoints_file > nkpoints:
        warn("truncating Hk points")
    elif kpoints_file < nkpoints:
        raise ValueError("problem! %d < %d" % (kpoints_file, nkpoints))
    kpoints = hk[:nkpoints, :3]

    # TODO: check with Martin if this the actual spin structure ...
    hk = hk[:nkpoints, 3:].reshape(nkpoints, nspins, nbands, nspins, nbands, 2)
    hk = hk[..., 0] + 1j * hk[..., 1]
    if not np.allclose(hk, hk.transpose(0, 3, 4, 1, 2).conj()):
        warn("Hermiticity violation detected in Hk file")

    # go from wannier90/convert_Hamiltonian structure to our Green's function
    # convention
    hk = hk.transpose(0, 2, 1, 4, 3)
    hk_file.close()

    Hk = np.squeeze(hk)
    kmesh = np.concatenate((kpoints,np.ones((np.shape(kpoints)[0],1))),1)

    return Hk, kmesh
# ==================================================================================================================


# ==================================================================================================================
def read_Hr_w2k(fname):
    '''
        Load the H(R) LDA-Hamiltonian from a wien2k hr file.
    '''
    Hr_file = pd.read_csv(fname, header = None,names = np.arange(15), sep = '\s+', dtype = float, engine='python')
    Nbands = Hr_file.values[0].astype(int)[0]
    Nr = Hr_file.values[1].astype(int)[0]

    tmp = np.reshape(Hr_file.values,(np.size(Hr_file.values),1))
    tmp = tmp[~np.isnan(tmp)]

    Rweights = tmp[2:2+Nr].astype(int)
    Rweights = np.reshape(Rweights,(np.size(Rweights),1))
    Ns = 7
    Ntmp = np.size(tmp[2+Nr:]) // Ns
    tmp = np.reshape(tmp[2+Nr:],(Ntmp,Ns))

    Rgrid = np.reshape(tmp[:,0:3],(Nr,Nbands,Nbands,3))
    orbs  = np.reshape(tmp[:,3:5],(Nr,Nbands,Nbands,2))
    Hr = np.reshape(tmp[:, 5] + 1j * tmp[:, 6],(Nr,Nbands,Nbands))
    return Hr, Rgrid, Rweights, orbs
# ==================================================================================================================


# ==================================================================================================================
def convham(Hr = None, Rgrid = None, Rweights = None, kmesh = None):
    '''
        Builds the k-space LDA-Hamiltonian from the real-space one.
        H(k) is constructed within the ir-BZ
        Hk (Nk,Nbands,Nbands)
    '''

    Nk = np.size(kmesh,1)
    Nband = np.size(Hr,1)
    Hk = np.zeros((Nk, Nband, Nband), dtype = complex)
    Rweights = np.squeeze(Rweights)
    for ib2 in range(Nband):
        for ib1 in range(Nband):
            for ik in range(Nk):
                FFTGrid = np.exp(1j * np.dot(np.squeeze(Rgrid[:,ib1,ib2,:]),kmesh[0:3,ik])) / Rweights
                Hk[ik,ib1,ib2] = np.sum(FFTGrid * Hr[:,ib1,ib2])
    return Hk
# ==================================================================================================================

# ==================================================================================================================
def convham2(Hr = None, Rgrid = None, Rweights = None, kmesh = None):
    '''
        Builds the k-space LDA-Hamiltonian from the real-space one.
        H(k) is constructed within the ir-BZ
        Hk (Nk,Nbands,Nbands)
    '''

    FFTGrid = np.exp(1j * np.matmul(Rgrid,kmesh)) / Rweights[:,None,None]
    Hk = np.transpose(np.sum(FFTGrid * Hr[...,None], axis=0),axes=(2,0,1))
    return Hk
# ==================================================================================================================

# ==================================================================================================================
def write_hk_wannier90(Hk, fname, kmesh, nk):
    '''
        Writes a Hamiltonian to a text file in wannier90 style.
    '''

    # .reshape(nk)
    # write hamiltonian in the wannier90 format to file
    f = open(fname, 'w')
    n_orb = np.shape(Hk)[-1]
    # header: no. of k-points, no. of wannier functions(bands), no. of bands (ignored)
    print(np.prod(nk), n_orb, n_orb, file=f)
    for ik in range(np.prod(nk)):
            print(kmesh[0, ik], kmesh[1, ik], kmesh[2, ik], file=f)
            np.savetxt(f, Hk[ik,...].view(float), fmt='%.12f',delimiter=' ', newline='\n', header='', footer='', comments='#')

    f.close()